**Overview: Quarkus Coffeeshop Architecture**

**Web Microservice:** Exposes a REST endpoint for order placement; publishes a PlaceOrderCommand to a Kafka topic (orders-in), and also streams order updates to the frontend via Server-Sent Events from web-updates

**Counter Microservice**: Consumes from orders-in, orchestrates sub-orders to Barista and Kitchen services, persists orders and events to PostgreSQL, and emits updates on orders-up and web-updates Kafka topics 

**Barista & Kitchen Microservices:** Listen to their respective input topics (barista-in / kitchen-in), process each order item, and publish completion updates back onto orders-up 

**Support Infrastructure:** Kafka, PostgreSQL, and pgAdmin are orchestrated via Docker Compose for local development 


**Migration choices to Spring**

(1) Separate Microservices from start

(2) Multi-module project with a parent module and sub-modules.

Going with (2) for starts, as this would perhaps be a straightforward migration (?)

```markdown
coffeeshop/
  ├── pom.xml  (parent)
  ├── web-service/
  ├── counter-service/
  ├── barista-service/
  └── kitchen-service/
```

Let's try and use start.spring.io

1. Generate one project on start.spring.io (this will act as the parent).
    Use Maven (not Gradle) since Maven’s multi-module setup is simpler.
    Add minimal dependencies (e.g., DevTools, maybe Spring Web).
    Artifact ID: coffeeshop-parent (or just coffeeshop).
2. Convert it into a parent POM:
    In the root pom.xml, remove the spring-boot-starter-parent declaration and replace it with a <packaging>pom</packaging>.
    Add <modules> listing your submodules (web-service, counter-service, etc.).
    Keep dependency management using spring-boot-dependencies.
3. Generate child services using start.spring.io
    Generate a web-service, counter-service, etc. individually (with their dependencies).
    Instead of keeping them standalone, move each one into subfolders under the parent project.
    Adjust each submodule’s pom.xml so its <parent> points to the parent POM.
4. Add a common module (optional but recommended)
    Place shared DTOs (like Order, PlaceOrderCommand) and Kafka config here.
    Other services can depend on it.

Resulting structure:
```markdown
coffeeshop/
  ├── pom.xml  (parent, type=pom)
  ├── common/
  │    └── pom.xml
  ├── web-service/
  │    └── pom.xml
  ├── counter-service/
  │    └── pom.xml
  ├── barista-service/
  │    └── pom.xml
  └── kitchen-service/
       └── pom.xml
```


**Quarkus Coffeeshop architecture**

    Web Service: exposes REST API (/order), publishes PlaceOrderCommand to Kafka, streams updates via SSE.

    Counter Service: consumes orders, persists state in PostgreSQL, orchestrates to Barista/Kitchen, and republishes events.

    Barista & Kitchen Services: listen for sub-orders, process, and publish completion events.

    Common: shared DTOs, events, and configs (used by all)


Map Quarkus features to Spring dependencies

1. Spring Web

    Needed anywhere there’s a REST API or Server-Sent Events (SSE).
    In Coffeeshop:
    Web Service → yes (REST + SSE).
    Counter Service → optional (REST endpoints for admin/health).
    Barista/Kitchen → optional (could expose health endpoints, but not required for Kafka-only).
2. Spring for Apache Kafka (spring-kafka)

    Quarkus uses SmallRye Reactive Messaging → maps to Spring’s Kafka integration.
    Needed in all services that produce or consume Kafka events:
    Web Service → produces orders-in.
    Counter Service → consumes orders-in, produces to Barista/Kitchen, consumes Barista/Kitchen responses, produces orders-up, web-updates.
    Barista & Kitchen Services → consume their respective topics, produce completion events.
3. Spring Data JPA + PostgreSQL Driver

    Quarkus uses Hibernate ORM + Panache with PostgreSQL in Counter Service.
    In Spring, the equivalent is Spring Data JPA with the PostgreSQL driver.
    Needed only by Counter Service (since that’s the one persisting orders/events).
4. Spring Boot Validation

    Quarkus uses Jakarta Bean Validation (@NotNull, @Valid) for request DTOs.
    Spring has the same feature via spring-boot-starter-validation.
    Useful in Web Service (for input validation) and Counter Service (for persistence layer validation).
5. DevTools

    Quality-of-life dependency → provides hot reload during dev.
    Not required for prod, but nice for all services.
6. Common Module

    Not generated by Quarkus, but in practice they share DTOs/events (like OrderPlaced, OrderIn, OrderUp).
    Makes sense to introduce a common module so all services can depend on a single definition.

| Service             | Required Dependencies                                                                                                                          |
| ------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------- |
| **web-service**     | `spring-boot-starter-web`, `spring-kafka`, `spring-boot-starter-validation`, devtools                                                          |
| **counter-service** | `spring-boot-starter-web` (optional), `spring-kafka`, `spring-boot-starter-data-jpa`, `postgresql`, `spring-boot-starter-validation`, devtools |
| **barista-service** | `spring-kafka`, (optional `spring-boot-starter-web` for health/admin), devtools                                                                |
| **kitchen-service** | `spring-kafka`, (optional `spring-boot-starter-web`), devtools                                                                                 |
| **common**          | no Spring Boot starter, just a plain JAR with DTOs/events/configs                                                                              |


**What goes in the Parent POM**

    Common to all (or most) child projects.
    Needed for consistent version alignment.
    Build tooling (plugins, Java version).

**What goes in the Child POMs**

    Each child should only declare what it actually uses.
    Web Service → needs spring-boot-starter-web, but not data-jpa.
    Counter Service → needs JPA + Postgres, but not SSE streaming.
    Barista/Kitchen → need Kafka, maybe Web.
    Common → probably no Spring Boot starters, just plain dependencies.

Use BOM in the parent for dependency management.

Using spring.initializr - realized that 3.5.4 release version was the best available choice.

**Rule of Thumb ??**

    Starters (spring-boot-starter-*) → always managed by the BOM.
    Supporting libraries (like Kafka client, PostgreSQL JDBC, Redis, etc.) → check if BOM lists them; if not, declare version in parent.
    Child modules → just reference what they need, no versions unless it’s outside the BOM.

| Dependency                       | Services                                                            | Part of Spring Boot BOM? | Notes                                               |
| -------------------------------- | ------------------------------------------------------------------- | ------------------------ | --------------------------------------------------- |
| `spring-boot-starter-web`        | web-service, counter-service (optional), barista/kitchen (optional) | ✅ Yes                    | Provides Spring MVC, embedded Tomcat/Netty, Jackson |
| `spring-boot-starter-data-jpa`   | counter-service                                                     | ✅ Yes                    | Hibernate ORM + JPA                                 |
| `org.postgresql:postgresql`      | counter-service                                                     | ❌ No                     | Must specify `${postgresql.version}` in parent      |
| `spring-kafka`                   | web-service, counter-service, barista-service, kitchen-service      | ✅ Yes                    | Spring for Apache Kafka                             |
| `spring-boot-starter-validation` | web-service, counter-service                                        | ✅ Yes                    | Bean validation (Jakarta Validation)                |
| `spring-boot-devtools`           | all services                                                        | ✅ Yes                    | Hot reload during development                       |
| `common` module (internal)       | all services                                                        | ❌ N/A                    | Plain JAR with DTOs/events, no BOM needed           |


Let's get with the steps.

(1) Create parent multi-module workspace

coffeeshop/
  common/
  web-service/
  counter-service/
  barista-service/
  kitchen-service/

(2) Create parent pom
    Java 21
    Spring 3.5.4 (boot BOM)
    dependency management
        postgres - as it is not managed by BOM
        spring-boot-maven-plugin

(3) Create skeletons for each of the child modules using spring.initializr

| Module              | Required Dependencies                            | Optional                                     |
| ------------------- | ------------------------------------------------ | -------------------------------------------- |
| **common**          | —                                                | Validation (only if you want DTO validation) |
| **web-service**     | Spring Web, Spring Kafka                         | Validation, DevTools                         |
| **counter-service** | Spring Data JPA, PostgreSQL Driver, Spring Kafka | Spring Web, Validation, DevTools             |
| **barista-service** | Spring Kafka                                     | DevTools                                     |
| **kitchen-service** | Spring Kafka                                     | DevTools                                     |


    common
        Group: com.coffeeshop
        Artifact: common
        Dependencies: (optional) Validation
        Download ZIP.
    web-service
        Group: com.coffeeshop
        Artifact: web-service
        Dependencies: Spring Web, Spring for Apache Kafka, (optional) Validation, (optional) DevTools
        Download ZIP.
    counter-service
        Group: com.coffeeshop
        Artifact: counter-service
        Dependencies: Spring Web, Spring for Apache Kafka, Spring Data JPA, PostgreSQL Driver, (optional) Validation, (optional) DevTools
        Download ZIP.
    barista-service
        Group: com.coffeeshop
        Artifact: barista-service
        Dependencies: Spring for Apache Kafka, (optional) DevTools
        Download ZIP.
    kitchen-service
        Group: com.coffeeshop
        Artifact: kitchen-service
        Dependencies: Spring for Apache Kafka, (optional) DevTools
        Download ZIP.
    Unzip all five zips to create respective folders in the parent folder.

Reparent each child POM, since spring.initializr doesn't do well with multi-module

a. Replace its <parent>...</parent> (which points to spring-boot-starter-parent) with:

    <parent>
        <groupId>com.coffeeshop</groupId>
        <artifactId>coffeeshop-parent</artifactId>
        <version>0.0.1-SNAPSHOT</version>
        <relativePath>../pom.xml</relativePath>
    </parent>
b. Remove any <version> tags on dependencies (Boot BOM manages them).
c. Remove any <version> tags on dependencies (Boot BOM manages them).
d. In services that need shared DTOs/events, add dependency on common:
    <dependency>
    <groupId>com.coffeeshop</groupId>
    <artifactId>common</artifactId>
    <version>${project.version}</version>
    </dependency>

Remove mvn and mvnw from each child module.

Create maven wrapper in the parent folder.

   mvn -N io.takari:maven:wrapper

Check if the skeleton compiles and runs.
    ./mvnw clean install
    ./mvnw spring-boot:run -pl web-service

Had to fix some errors.

    a. Had to remove CommonApplication.java and corresponding test class from common submodule.
        It's going to be only a library module.  No need to have this class.

    b. For the modules with test classes, needed to add this to their pom.
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-test</artifactId>
                <scope>test</scope>
            </dependency>
            
    c. Had to disable auto-configuration for test in counter-service, because at this point it is just a skeleton and fails to configure datasource.
            @SpringBootTest
            @EnableAutoConfiguration(exclude = {DataSourceAutoConfiguration.class})
            class CounterServiceApplicationTests {
                // test code
            }
    
    d. For those modules that are not web or jpa, had to add spring-boot-starter in the pom.
                <!-- Spring Boot starter -->
                <dependency>
                    <groupId>org.springframework.boot</groupId>
                    <artifactId>spring-boot-starter</artifactId>
                </dependency>
        
    
| Module              | Purpose / Type              | `@SpringBootApplication`? | Required Starter(s)                                                       | Notes                                                                                                  |
| ------------------- | --------------------------- | ------------------------- | ------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------ |
| **common**          | Shared library / utilities  | No                        | None                                                                      | Only add libraries actually used (e.g., commons-lang). Should **not** include Spring Boot starters.    |
| **web-service**     | Exposes REST APIs           | Yes                       | `spring-boot-starter-web` (includes `spring-boot-starter`)                | Starter brings in Spring Boot core classes transitively.                                               |
| **counter-service** | Handles business logic / DB | Yes                       | `spring-boot-starter-web` (or `spring-boot-starter-data-jpa` if using DB) | Starter brings in core Spring Boot classes. Add test starter with `test` scope.                        |
| **barista-service** | Runnable service / worker   | Yes                       | `spring-boot-starter` (minimal)                                           | Must include explicitly, otherwise `@SpringBootApplication` / `SpringApplication` classes are missing. |
| **kitchen-service** | Runnable service / worker   | Yes                       | `spring-boot-starter` (or additional starters as needed)                  | Same reasoning as barista-service. Add web or DB starters only if needed.                              |


Now compilation is fixed.

A test run of web-service skeleton module worked.  

Browser reached base URL.

Note that we don't have any controllers/end-points yet.


**Now for the next steps.**

1. Copy the original quarkus version of java classes to our skeleton, one module after the other.

2. Identify and Map Quarkus Components to Spring

**Controllers / REST endpoints**

    Quarkus usually uses @Path + @GET/@POST on resource classes.
    Spring uses @RestController, @RequestMapping, @GetMapping, @PostMapping.
    Action:
        Make a list of all resource classes in the Quarkus app.
        For each endpoint, note the path, HTTP method, and request/response types.

**Services / Business Logic**

    Quarkus usually uses CDI beans with @ApplicationScoped.
    Spring uses @Service or @Component for beans.
    Action:
        Identify all services in Quarkus.
        Map them to Spring @Service classes.
        Check if they inject other beans (@Inject) — in Spring, use @Autowired or constructor injection.

**Persistence / Repositories**

    Quarkus uses PanacheRepository or JPA.
    Spring uses spring-boot-starter-data-jpa + @Repository or Spring Data JPA interfaces.
    Action:
        Identify all entities and repositories in Quarkus.
        For each entity, migrate to a Spring @Entity.
        For each repository, create a Spring Data JPA interface extending JpaRepository<Entity, ID>.

**Configuration / Properties**

    Quarkus uses application.properties or application.yaml.
    Spring uses application.properties / application.yml.
    Action:
        Copy relevant configuration.
        Map Quarkus-specific properties to Spring equivalents (e.g., datasource, Kafka, messaging).

**Dependency Injection / Context**

    Quarkus uses CDI.
    Spring uses its own DI container.
    Action:
        Replace @Inject with Spring injection (@Autowired or constructor-based).
        Ensure all beans are defined as @Component, @Service, @Repository, or via @Configuration.